# Sort
## 1. 선택 정렬
- 첫번째 원소를 두번째 원소부터 마지막 까지 비교 후, 가장 작은 값을 찾아 첫번째 원소로 이동시키고, 차례대로 비교하면서 작은 값을 비교하는 원소의 첫번째에 두는 과정을 반복하면서 정렬하는 알고리즘
- 자료 이동 횟수가 미리 결정되며, 상대적인 위치가 변경될 수 있다
- 시간복잡도 : ```O(N^2)```
## 2. 삽입 정렬
- 두번째 자료부터 시작하여, 왼쪽의 자료와 비교하여 삽입할 위치를 정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입한 후 정렬하는 알고리즘
- 배열 요소의 갯수가 적으면 다른 정렬방법 보다 유리하고, 레코드가 정렬되어 있는 경우에 효율적이라는 장점
- 요소들이 많이 이동해야 한다는 단점이 있음
- 시간복잡도
    - best : 이동없이 한번의 비교만 진행되므로 ```O(N)```
    - worst : 각 반복마다 n번씩 비교하므로 ```O(N^2)```
## 3. 버블 정렬
- 서로 인접한 원소를 비교하여 이동 후 정렬하는 알고리즘
- 1회전을 수행하면 가장 큰 값이 맨 뒤로 이동하고, 1회전을 수행할 때마다 정렬에서 제외되는 데이터가 늘어남
- 구현이 간단하다는 장점이 있음
- 특정 요소가 최종 정렬 위치에 있는 경우라도 교환이 발생한다는 단점이 잇음
- 시간복잡도 : ```O(N^2)```
## 4. 합병 정렬
- 하나의 배열을 입력받아 배열의 크기가 1보다 작거나 같을 때 까지 반복하면서 두개의 배열로 계속 쪼개 나간 뒤,합치면서 하나의 정렬을 출력하는 알고리즘
- 시간복잡도 : ```O(NlogN)```
## 5. 퀵 정렬
- 피벗을 두어 피벗 앞에는 피벗보다 작은수, 뒤에는 피벗보다 큰 값이 오도록 배열을 두개로 나누고, 두개의 배열을 재귀적으로 호출한 뒤 왼쪽 피벗이 오른쪽 피벗보다 커지는 경우 return 하는 알고리즘
- 최악의 경우 시간복잡도 ```O(N^2)```이 발생하는데 이 경우 배열의 왼쪽값, 오른쪽값, 중간의 값을 사용해서 오름차순으로 정렬해서 시간복잡도를 개선할 수 있다.
- 시간복잡도
    - best : ```O(NlogN)```
    - worst : ```O(N^2)```