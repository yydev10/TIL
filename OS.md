# Operating system (운영체제)

## Process

### Process의 5단계 상태
- new : 프로세스가 생성 된 직 후
- running : CPU가 프로세스를 점유하면서 실행되서 명령어가 실행되는 상태
- waiting : 자원을 사용하기 위해서 CPU가 다른 작업을 끝낼 때 까지 기다리는 상태 
- ready : I/O에 대기하며 CPU가 점유되기 전의 상태를 의미
- terminated : 프로세스가 완료되거나 외부로 부터 강제 종료한 상태

### Scheduling Algorithms
#### SJF(Shortest Job First)
- 가장 CPU 작업시간이 작은 프로세스 부터 먼저 수행하는 스케쥴링 기법
- 실행시간이 짧은 작업을 신속하게 실행 하므로 평균 대기시간이 다른 스케쥴링 기법보다 짧다
- 프로세스 시작 전 프로세스의 작업 시간을 파악하기 어렵기 때문에 프로세스의 작업시간을 예측하는 과정을 거쳐야 된다. 현실적으로 적용하기 어려운 알고리즘이다

### Thread 동기화
#### mutex(뮤텍스) - spinlock(스핀락)
- mutex와 spinlock 둘 다 자원에 lock이 걸린 경우 lock이 풀릴 때 까지 대기해야 하는 특성을 가진다,
- mutex는 이미 자원에 lock이 걸린 경우 풀릴 때 까지 context switching을 실행한다. 
- 자원을 짧은 시간 내로 얻는 경우 context switching의 오버헤드가 커져 자원을 낭비하는 문제가 있다
- spinlock은 자원에 lock이 걸려 있는 경우 무한루프를 돌면서 대기한다.
- 자원을 짧은 시간 내에 획득하는 경우에는 context switching 비용이 들지 않기 때문에 효율을 높인다
- 반대의 경우 대기하는 시간이 증가하므로 CPU 효율을 떨어트리는 문제가 발생한다.

### Paging
- 외부 단편화 문제를 해결하기 위해 프로세스의 논리 주소 공간을 떨어진 공간에 배정할 수 있도록 지원하는 메모리 관리 기법
- 고정 크기로 분할 하기 때문에 구현이 편하고, 시스템에 따라 page의 크기를 다르게 설정할 수 있다
- 페이지 단위를 작게 하여 내부단편화 발생 문제를 해결할 수 있지만, 매핑 과정이 복잡해 지기 때문에 비효율적이다

### 커널
- OS의 핵심 기능을 실행하는 코드와 데이터, 부팅 후 메모리에 상주하는 영역
- 커널 코드는 운영체제에서 제공하는 함수들의 집합으로 구성
- 어플리케이션에서 커널코드를 이용하기 위해 시스템 콜을 사용
- 어플리케이션이 컴퓨터 자원에 접근하면 충돌 혹은 훼손이 발생할 가능성이 있기 때문에 자원에 대한 접근 권한은 커널에만 부여
- 커널코드를 실행하기 위해 CPU 실행 모드를 커널 모드로 접근해야함

### 메모리 관리 기법
#### 외부 단편화
- 남아있는 메모리 공간이 요청한 메모리 공간보다 크지만 남아있는 공간이 연속적인 홀이 아니여서 발생
- 메모리 압축 기법으로 해결 가능
- 메모리 압축 기법 
    - 주기억 장치 내 분산되어 있는 단편화된 공간을 통합해 하나의 커다란 빈 공간을 만드는 작업
    - 주소 재할당이 동적인 경우만 가능하며 압축을 진행하는 시간으로 시스템 성능이 저하될 수 있음
#### 내부 단편화
- 할당된 메모리가 요구한 메모리보다 더 커서 프로세스에 할당된 메모리 내부에 사용할 수 없는 홀이 생기는 현상
- 파티션의 크기를 줄이면서 완화될 수 있지만, 메모리 관리의 효율성은 떨어진다