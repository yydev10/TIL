# Operating system (운영체제)

## OS
- 컴퓨터 하드웨어와 컴퓨터 사용자 간의 인터페이스로 동작하는 시스템 소프트웨어
- 컴퓨터의 하드웨어, 소프트웨어 자원을 효율적으로 관리한다. 
- 부팅 시 메모리에 적재되어 실행을 시작하고 컴퓨터 종료시 까지 실행된다.
- 커널 코드로 컴퓨터의 모든 자원에 대해 배타적 독점해서 사용할 수 있는 권한이 있다

## Process
### Process의 5단계 상태
- new : 프로세스가 생성 된 직 후
- running : CPU가 프로세스를 점유하면서 실행되서 명령어가 실행되는 상태
- waiting : 자원을 사용하기 위해서 CPU가 다른 작업을 끝낼 때 까지 기다리는 상태 
- ready : I/O에 대기하며 CPU가 점유되기 전의 상태를 의미
- terminated : 프로세스가 완료되거나 외부로 부터 강제 종료한 상태

### IPC(프로세스 간 통신 방법)
1. 공유 메모리 
- 프로세스가 메모리 할당을 커널에 요청, 커널은 해당 프로세스에 공유 메모리 공간을 할당한다. 
- 메모리 영역이 구축된 이후 어떤 프로세스 건 메모리 영역에 접근 가능하고, 이때 프로세스가 메모리 영역에 첨부되는 방식으로 작동한다
- 프로세스 간 Read, Write를 모두 필요로 할 때 사용한다
- 중개자 없이 바로 메모리에 접근 가능하고, IPC중 가장 빠르게 작동한다

2. 파이프(pipe)
- 통신을 위한 메모리 공간을 생성하여 프로세스가 데이터를 주고 받는 방식
- 운영체제에서 제공하는 Pipe는 단방향 통신을 제공하기 때문에 양방향 통신을 하기 위해서는 파이프 2개를 활용해서 통신
3. 소켓(socket)
- 동일한 호스트 운영체제에서 실행되는 프로세스 간 데이터를 교환하기 위한 데이터 통신 엔드포인트
- 네트워크 소켓통신을 통해 데이터를 공유
- 데이터 교환을 위해 pc에서 임의의 포트를 정하고 포트 간에 데이터를 주고받는 방식

#### 프로세스 간 동기화 기법
세마포어 - 뮤텍스

### Thread 동기화
- mutex와 spinlock 둘 다 자원에 lock이 걸린 경우 lock이 풀릴 때 까지 대기해야 하는 특성을 가진다
#### mutex(뮤텍스) 
- 이미 자원에 lock이 걸린 경우 풀릴 때 까지 context switching을 실행한다. 
#### spinlock(스핀락)


- 자원을 짧은 시간 내로 얻는 경우 context switching의 오버헤드가 커져 자원을 낭비하는 문제가 있다
- spinlock은 자원에 lock이 걸려 있는 경우 무한루프를 돌면서 대기한다.
- 자원을 짧은 시간 내에 획득하는 경우에는 context switching 비용이 들지 않기 때문에 효율을 높인다
- 반대의 경우 대기하는 시간이 증가하므로 CPU 효율을 떨어트리는 문제가 발생한다.

### Scheduling Algorithms
#### SJF(Shortest Job First)
- 가장 CPU 작업시간이 작은 프로세스 부터 먼저 수행하는 스케쥴링 기법
- 실행시간이 짧은 작업을 신속하게 실행 하므로 평균 대기시간이 다른 스케쥴링 기법보다 짧다
- 프로세스 시작 전 프로세스의 작업 시간을 파악하기 어렵기 때문에 프로세스의 작업시간을 예측하는 과정을 거쳐야 된다. 현실적으로 적용하기 어려운 알고리즘이다



### Paging
- 외부 단편화 문제를 해결하기 위해 프로세스의 논리 주소 공간을 떨어진 공간에 배정할 수 있도록 지원하는 메모리 관리 기법
- 고정 크기로 분할 하기 때문에 구현이 편하고, 시스템에 따라 page의 크기를 다르게 설정할 수 있다
- 페이지 단위를 작게 하여 내부단편화 발생 문제를 해결할 수 있지만, 매핑 과정이 복잡해 지기 때문에 비효율적이다

### 커널
- OS의 핵심 기능을 실행하는 코드와 데이터, 부팅 후 메모리에 상주하는 영역
- 커널 코드는 운영체제에서 제공하는 함수들의 집합으로 구성
- 어플리케이션에서 커널코드를 이용하기 위해 시스템 콜을 사용
- 어플리케이션이 컴퓨터 자원에 접근하면 충돌 혹은 훼손이 발생할 가능성이 있기 때문에 자원에 대한 접근 권한은 커널에만 부여
- 커널코드를 실행하기 위해 CPU 실행 모드를 커널 모드로 접근해야함

### 메모리 관리 기법
#### 외부 단편화
- 남아있는 메모리 공간이 요청한 메모리 공간보다 크지만 남아있는 공간이 연속적인 홀이 아니여서 발생
- 메모리 압축 기법으로 해결 가능
- 메모리 압축 기법 
    - 주기억 장치 내 분산되어 있는 단편화된 공간을 통합해 하나의 커다란 빈 공간을 만드는 작업
    - 주소 재할당이 동적인 경우만 가능하며 압축을 진행하는 시간으로 시스템 성능이 저하될 수 있음
#### 내부 단편화
- 할당된 메모리가 요구한 메모리보다 더 커서 프로세스에 할당된 메모리 내부에 사용할 수 없는 홀이 생기는 현상
- 파티션의 크기를 줄이면서 완화될 수 있지만, 메모리 관리의 효율성은 떨어진다

### 세그먼테이션
- 프로세스를 연관된 정보들의 집합으로 나눠서 메모리에 배치하는 기법으로 외부단편화가 발생할 수 있다
- 구현
    - 프로세스를 세그먼트의 집합으로 만들고, 내부적으로 code, data, heap, stack 세그먼트로 나눈다
    - 세그먼트를 메모리에 할당할 때 세그먼트 테이블을 활용하는데, 세그먼트 크기(limit)와 세그먼트 시작 물리주소(base)로 구성되어 있다
- 주소변환
    - 세그먼트에서 주소변환을 하는 경우 세그먼트 테이블을 통해 논리주소를 물리주소로 변환
    - 세그먼트의 크기를 넘어서는 주소가 들어오는 경우 해당 프로세스를 강제로 종료

### PCB(Process Control Block)
- 커널 영역에 프로세스 테이블을 통해 프로세스 목록과 정보를 관리하는 자료구조
- 프로세스가 생성될 때마다 고유의 PCB가 생성되고 프로세스가 완료되면 PCB도 함께 제거
- PCB에 저장되는 정보
    - pointer : 프로세스의 위치를 저장하는 포인터
    - process 상태 : 프로세스의 각 상태 저장
    - program counter : 실행될 다음 명령어 주소를 포함하는 카운터 저장
    - open file 목록 : 프로세스를 위해 열린 파일 목록이 포함됨

### Context Switching
- 멀티 프로세스 환경에서 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청으로 프로세스가 실행되어야 할 때 기존 레지스터 값을 저장하고 CPU가 프로세스를 수행할 수 있도록 프로세스의 context를 교체하는 작업
- 인터럽트가 발생하는 경우
    - 입출력 요청
    - CPU 사용시간 만료
    - 자식 프로세스 생성
    - 인터럽트 처리를 기다릴 때

## 페이지 교체 알고리즘
### FIFO
- 가장 오래된 page frame을 먼저 교체하는 알고리즘
- 각 frame은 메모리에 적재되는 순서에 따라 순번이 매겨진다
- FIFO 큐를 이용
- 프레임을 더 많이 사용하는데 페이지 fault 횟수가 증가하는 이상현상이 발생할 수 있음
### Optimal Page
- 최적 페이지 교체 알고리즘으로 앞으로 가장 오랫동안 사용되지 않을 page frame을 교체한다
- 향후의 프로그램이 어떻게 수행될 지 예측이 불가능하기 때문에 비현실적
### LRU
- 최근에 적게 사용한 page frame을 앞으로도 미사용할 page로 간주하고 최근에 적게 사용된 page frame을 교체하는 알고리즘
- 각 page frame 마다 마지막 사용시간을 유지한다
- 모순현상이 나타나지 않기 때문에 일반적으로 좋은 성능을 띈다
### LFU
- 참조 횟수가 가장 적은 페이지를 교체하는 알고리즘
- 교체 대상이 여러개라면 가장 오랫동안 사용하지 않은 페이지를 교체
### MFU
- 참조횟수가 가장 많은 페이지를 교체하는 알고리즘